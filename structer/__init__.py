"""
Interpret packed binary data using named attributes
The namespace classes and metaclasses here allow variants
of classes to be generated by calling them with keyword arguments.
"""

from os import stat
from mmap import mmap, PROT_READ

def memmap(name):
    """
    memoryview over readonly mmap of file with specified name
    Allow empty files even if mmap rejects them
    """
    with open(name, 'rb') as file:
        try:
            return memoryview(mmap(file.fileno(), 0, access=PROT_READ))
        except ValueError:
            assert stat(file.fileno()).st_size == 0
            return memoryview(b'')

class CacheAttr(object):
    """
    Descriptor which replaces itself with the value it returns
    """
    def __init__(self, fget):
        self.fget = fget

    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self.fget(instance)
        setattr(instance, self.fget.__name__, value)
        return value

class ClassAttr(object):
    """
    A property descriptor for accessing attributes from a class
    This allows class attributes to be calculated from keyword values.
    """
    def __init__(self, fget):
        self.fget = fget

    def __get__(self, instance, owner):
        return self.fget(owner)

NULL = type(vars(dict))({})

class NameBase(object):
    """
    Base class for metaclass namespaces; subclasses inherit from specific collection types.
    The __mapping__ attribute tracks recognized keywords
    The __member__ attribute is handled by subclasses
    A keyword is recognized if a default value is provided in a class declaration.
    """
    def __init__(self, __mapping__=NULL, __member__=(), __iterable__=(), **kwargs):
        self.__mapping__ = {**__mapping__, **kwargs}
        self.__member__ = __member__
        super().__init__(__iterable__)

    def __call__(self, **kwargs):
        kwargs = {key: value for key, value in kwargs.items()
                  if key in self.__mapping__ and kwargs[key] != self.__mapping__[key]}
        return type(self)(self.__mapping__, self.__member__, self, **kwargs) if kwargs else self

    def __getattr__(self, name):
        try:
            return self.__mapping__[name]
        except KeyError:
            raise AttributeError

class NameSpace(NameBase, dict):
    """
    metaclass namespace
    """

class NameList(NameBase, list):
    """
    Sequence of callable members with a mapping from name to index
    This tracks named.Struct members.
    """
    def append(self, item, name):
        if name in self.__mapping__:
            raise KeyError
        self.__mapping__[name] = len(self)
        super().append(item)

    def __call__(self, **kwargs):
        elements = type(self)(__iterable__=(element(**kwargs) for element in self))
        same = all(new is old for new, old in zip(elements, self))
        return type(self)(self.__mapping__, self.__member__, elements) if not same else self

def base_keywords(bases):
    """
    Extract keywords from compatible base classes
    A class with a __namespace__ attribute is considered compatible
    This allows enum.Enum subclasses to provide a __struct_format__ attribute.
    """
    mapping = {}
    for base in bases:
        try:
            mapping.update(**base.__namespace__.__mapping__)
        except AttributeError:
            pass
    return mapping

class Meta(type):
    """
    metaclass for keyword-specified classes which replicate variants
    """
    @classmethod
    def __prepare__(mcs, name, bases, **kwargs):
        return NameSpace(__mapping__=base_keywords(bases), **kwargs)

    def __new__(mcs, name, bases, namespace, **kwargs):
        return super().__new__(mcs, name, bases, namespace)

    def __init__(cls, name, bases, namespace, **kwargs):
        cls.__namespace__ = namespace
        super().__init__(name, bases, namespace)

    def __call__(cls, *args, **kwargs):
        namespace = cls.__namespace__(**kwargs)
        if namespace is not cls.__namespace__:
            cls = type(cls)(cls.__name__, cls.__bases__, namespace, **kwargs)
        return super().__call__(*args) if args else cls

    def __getattr__(cls, name):
        return getattr(cls.__namespace__, name)
